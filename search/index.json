[{"content":"Regardless of whether you are writing AVM modules, or simply using them, it is useful to understand the \u0026ldquo;shared interfaces\u0026rdquo;, as described on the AVM website.\nEach module must implement the following interfaces if they are supported by the underlying resource:\nWhat does this mean as a module consumer? It means there should be a module input available for each of these:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 module \u0026#34;keyvault\u0026#34; { source = \u0026#34;Azure/avm-res-keyvault-vault/azurerm\u0026#34; version = \u0026#34;0.5.1\u0026#34; name = module.naming.key_vault.name_unique location = azurerm_resource_group.this.location resource_group_name = azurerm_resource_group.this.name tenant_id = data.azurerm_client_config.this.tenant_id sku_name = \u0026#34;standard\u0026#34; role_assignments = { # define the role assignments } lock = { # define the resource locks } private_endpoints = { # define the private endpoints } diagnostic_settings = { # define the diagnostic settings } // etc tags = var.tags } Whether you use them, is optional. Lets dive into some examples!\nRole Assignments example We\u0026rsquo;ll make a couple role assignments for a Key Vault, one for a pretend app, and another for the principal running the devops pipeline (say, to let the pipeline update secrets).\nHere\u0026rsquo;s how you might be tempted to write this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 module \u0026#34;keyvault\u0026#34; { source = \u0026#34;Azure/avm-res-keyvault-vault/azurerm\u0026#34; version = \u0026#34;0.5.1\u0026#34; name = local.keyvault_name enable_telemetry = false resource_group_name = data.azurerm_resource_group.parent.name location = local.location tenant_id = data.azurerm_client_config.this.tenant_id purge_protection_enabled = false sku_name = \u0026#34;standard\u0026#34; tags = var.tags } resource \u0026#34;azurerm_role_assignment\u0026#34; \u0026#34;my_app_secrets_user\u0026#34; { scope = module.keyvault.resource.id role_definition_name = \u0026#34;Key Vault Secrets User\u0026#34; principal_id = \u0026#34;a2b9c8d7-1e3f-42c5-b6a7-c8e9l0d1e2a3\u0026#34; # this is a made up ID! } resource \u0026#34;azurerm_role_assignment\u0026#34; \u0026#34;devops_principal_secrets_officer\u0026#34; { scope = module.keyvault.resource.id role_definition_name = \u0026#34;Key Vault Secrets Officer\u0026#34; principal_id = data.azurerm_client_config.example.object_id } AVM: Key vault role assignment This is perfectly valid, and it will work, but in AVM you can provide the role assignment directly to the module, like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module \u0026#34;keyvault\u0026#34; { source = \u0026#34;Azure/avm-res-keyvault-vault/azurerm\u0026#34; version = \u0026#34;0.5.1\u0026#34; name = local.keyvault_name resource_group_name = data.azurerm_resource_group.parent.name location = local.location tenant_id = data.azurerm_client_config.this.tenant_id purge_protection_enabled = false sku_name = \u0026#34;standard\u0026#34; tags = var.tags role_assignments = { my_app_secrets_user = { role_definition_id_or_name = \u0026#34;Key Vault Secrets User\u0026#34; principal_id = \u0026#34;a2b9c8d7-1e3f-42c5-d6i7-c8k9l0a1b2e3\u0026#34; # this is a made up ID! }, devops_principal_secrets_officer = { role_definition_id_or_name = \u0026#34;Key Vault Secrets Officer\u0026#34; principal_id = data.azurerm_client_config.this.object_id }, } } The name of the keys (\u0026ldquo;my_app_secrets_user\u0026rdquo; and \u0026ldquo;devops_principal_secrets_officer\u0026rdquo;) is arbitrary but should be statically named. This relates to the correct use of \u0026ldquo;for each\u0026rdquo;, which is explained in this video from Matt White\u0026rsquo;s YouTube channel.\nPrivate endpoint example The way to specify a private endpoint is similar, you can see it in full in one of the end-to-end tests in the official KeyVault repository.\nHere is the relevant snippet for illustration:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 module \u0026#34;keyvault\u0026#34; { source = \u0026#34;Azure/avm-res-keyvault-vault/azurerm\u0026#34; version = \u0026#34;0.5.1\u0026#34; name = module.naming.key_vault.name_unique location = azurerm_resource_group.this.location resource_group_name = azurerm_resource_group.this.name tenant_id = data.azurerm_client_config.this.tenant_id public_network_access_enabled = false private_endpoints = { primary = { private_dns_zone_resource_ids = [azurerm_private_dns_zone.this.id] subnet_resource_id = azurerm_subnet.this.id } } } The important point, is the same interface is shared between resources, which means if you know how to add a role assignment or a private endpoint to a Key Vault, it is the same for a Storage Account, Database etc.\nWait, this looks like CARML? Seasoned followers of the Bicep will likely recognise this approach from the CARML library\nThat is no accident! AVM seeks to align the experience between Bicep and Terraform resource modules, whilst acknowledging recommended practices from each language.\nChild resources The scoping of child resources with the parent module is another example where the Terraform and Bicep approach is united. Below illustrates what the looks like for Key Vault:\nAVM: create a secret As an example, secrets can be defined like this (line 29 onwards):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 data \u0026#34;http\u0026#34; \u0026#34;my_ip\u0026#34; { url = \u0026#34;https://ifconfig.me/ip\u0026#34; } module \u0026#34;keyvault\u0026#34; { source = \u0026#34;Azure/avm-res-keyvault-vault/azurerm\u0026#34; version = \u0026#34;0.5.1\u0026#34; name = module.naming.key_vault.name_unique enable_telemetry = var.enable_telemetry location = azurerm_resource_group.this.location resource_group_name = azurerm_resource_group.this.name tenant_id = data.azurerm_client_config.this.tenant_id purge_protection_enabled = false public_network_access_enabled = true # so we can check the secrets get created ok. sku_name = \u0026#34;standard\u0026#34; tags = var.tags network_acls = { ip_rules = [data.http.my_ip.response_body] } role_assignments = { devops_principal_secrets_officer = { role_definition_id_or_name = \u0026#34;Key Vault Secrets Officer\u0026#34; principal_id = data.azurerm_client_config.this.object_id }, } secrets = { \u0026#34;my_first_secret\u0026#34; = { name = \u0026#34;my-1st-secret\u0026#34; # name only supports alphanumeric \u0026amp; dashes } } # secret values are marked as sensitive and thus can not be used in a for_each loop secrets_value = { \u0026#34;my_first_secret\u0026#34; = random_password.second_secret.result, } } A few things to call out in the above:\nSecrets are specified as a map supplied to the secrets variable. A separate variable is used for secrets_value because it is marked as sensitive and therefore cannot be used in a \u0026ldquo;for_each\u0026rdquo; loop. The map key (e.g. \u0026ldquo;my_first_secret\u0026rdquo;) needs to match between the secret \u0026amp; the secret_value. Since RBAC \u0026amp; the firewall is enabled, I\u0026rsquo;m creating a role for the pipeline to be able to create the secret, and updating the IP restrictions based on the runner\u0026rsquo;s IP. In an enterprise, this would typically be done using a self-hosted runner.\nHere\u0026rsquo;s a more complex block that illustrates AVM support for all secret parameters:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 secrets = { \u0026#34;my_first_secret\u0026#34; = { name = \u0026#34;my-1st-secret\u0026#34; } \u0026#34;my_second_secret\u0026#34; = { name = \u0026#34;my-2nd-secret\u0026#34; # optional parameters description = \u0026#34;this is a very important secret that does important things\u0026#34; content_type = \u0026#34;text/plain\u0026#34; expiration_date = \u0026#34;2024-08-01T00:00:00Z\u0026#34; not_before_date = \u0026#34;2024-01-01T14:30:00+12:00\u0026#34; # 14:30 on 1st Jan 2024 UTC+12 tags = merge(var.tags, { my_extra_tag_for_secret = \u0026#34;top secret\u0026#34; }) } } secrets_value = { \u0026#34;my_first_secret\u0026#34; = random_password.second_secret.result, \u0026#34;my_second_secret\u0026#34; = random_password.second_secret.result } Role assignments for child resources The pattern for shared interfaces continues down to child resource - again AVM specifies that child resources must implement the shared interfaces if they are supported by the resource. Here\u0026rsquo;s a picture to explain:\nAVM: secrets with role assignments Here is the secret block showing a role assignment against an individual secret:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 secrets = { \u0026#34;my_first_secret\u0026#34; = { name = \u0026#34;my-1st-secret\u0026#34; } \u0026#34;my_second_secret\u0026#34; = { name = \u0026#34;my-2nd-secret\u0026#34; # illustrating a role assignment for a specific secret role_assignments = { my_test_group = { role_definition_id_or_name = \u0026#34;Key Vault Secrets User\u0026#34; # make sure you use a principal that exists in Entra ID! principal_id = \u0026#34;8391afd1-838e-8097-aefd-6e6e9841959f\u0026#34; } } } } # secret values are marked as sensitive and thus can not be used in a for_each loop secrets_value = { \u0026#34;my_first_secret\u0026#34; = random_password.second_secret.result, \u0026#34;my_second_secret\u0026#34; = random_password.second_secret.result } This same approach is repeated for other resources, for instance creating role assignments against a storage container.\nFind the code on GitHub You can find the role assignment \u0026amp; secret examples on my GitHub:\nhttps://github.com/kewalaka/terraform-avm-keyvault-examples\nExamples for Private endpoint \u0026amp; diagnostic settings are available in the end to end tests for the KeyVault Module:\nhttps://github.com/Azure/terraform-azurerm-avm-res-keyvault-vault/tree/main/examples\n","date":"2024-02-06T10:56:47+13:00","image":"https://blog.kewalaka.nz/p/2024/02/avm-resource-interfaces/i_am_your_parent_huc23435601578979f25568bab33f71934_24123_120x120_fill_box_smart1_3.png","permalink":"https://blog.kewalaka.nz/p/2024/02/avm-resource-interfaces/","title":"AVM module interfaces \u0026 their children"},{"content":"This is a post about writing your first Azure Verified Modules, for those interested in the background about AVM, check out this recent intro on YouTube.\nThis is recommended as a learning exercise to familiarise yourself with AVM. I strongly encourage contributing to the official resource modules Microsoft is in the process of building.\nWe\u0026rsquo;re going to focus on writing a resource module:\nIt is recommended to use a unix-based system for writing AVM modules (e.g. either WSL2, a Mac, a Linux variant, or GitHub codespaces).\nI assume a familiarity with git, including how to clone and create feature branches.\nThe process is going to be:\nCheck if the AVM module already exists \u0026amp; understand resource module naming conventions. Create a new GitHub repo for the module from the AVM template. Update the GitHub repo to enable support for running \u0026rsquo;end to end\u0026rsquo; tests in GitHub actions. Build the resource module, using the newres tool. Let\u0026rsquo;s get started!\nCheck for an existing module If a module already exists, we should use or contribute to the existing one. They are all listed on the AVM website.\nBear in mind that many resources are not available yet, as this initiative is new. We\u0026rsquo;re going to pick \u0026ldquo;Dev Center\u0026rdquo; for this example, as it doesn\u0026rsquo;t yet exist in AVM for Terraform.\nAVM Module naming If you can\u0026rsquo;t find the resource, lets make one! We\u0026rsquo;ll start by understanding the module naming conventions.\nAVM modules are named as per the spec, to summarise it should look something like this:\n1 avm-res-\u0026lt;resource provider\u0026gt;-\u0026lt;ARM resource type\u0026gt; The resource provider should not include the \u0026ldquo;Microsoft.\u0026rdquo; part. The resource type should be in singular form. Here are some examples to help:\n1 2 3 avm-res-containerregistry-registry avm-res-storage-storageaccount avm-res-keyvault-vault The GitHub repo name is prefixed with terraform-azurerm- to allow it to be published correctly in the Hashicorp public registry.\nSo, for example, the KeyVault GitHub repository would be:\nhttps://github.com/Azure/terraform-azurerm-avm-res-keyvault-vault\nRaise a module proposal If you\u0026rsquo;re planning to contribute back (I strongly encourage it!), it is a good idea to raise an issue, this will help validate the module naming \u0026amp; scope and start the process to find a Microsoft FTE to support the module.\nYou can raise a module proposal using this issue template: https://aka.ms/AVM/ModuleProposal.\nA practical example Lets get started making the Dev Centre resource module in Terraform, this is co-incidentally something I need as a pre-requisite to building a Dev Box in Azure.\nIt\u0026rsquo;s a very simple example with a limited number of inputs, a good place to start!\nWe\u0026rsquo;ll check the Hashicorp documentation to make sure there is support for it in the AzureRM Terraform provider, and here it is:\nhttps://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/dev_center\nRemember, if AzureRM isn\u0026rsquo;t available, there\u0026rsquo;s always AzAPI, but that is for another day.\nYou may need to register \u0026ldquo;Microsoft.DevCenter\u0026rdquo; in your subscription resource providers if you are following along:\nUse the AVM template There is a an AVM module template repository to help get you started.\nThe repo name will be terraform-azurerm-avm-res-devcenter-devcenter:\nGitHub settings (TODO link to another guide with more detail for peeps that need it)\nWithin your cloned repo on Github, do the following:\nSet up a GitHub repo environment called test. Configure environment protection rule to ensure that approval is required before deploying to this environment. Create a user-assigned managed identity in your test subscription. Create a role assignment for the managed identity on your test subscription, recommend providing this \u0026ldquo;Contributor\u0026rdquo; and \u0026ldquo;Role Based Access Control Administrator\u0026rdquo;. Configure federated identity credentials on the user assigned managed identity. Use the GitHub environment. Set the following secrets on your GitHub environment: AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID - i.e. the subscription you will be using to deploy resources to test the module. AZURE_CLIENT_ID - i.e. the client id of the managed identity. Clone \u0026amp; feature branch Clone down the repository and open it in your preferred editor (I use Visual Studio Code).\nCreate a new feature branch for the initial version updates.\nInstall the \u0026ldquo;newres\u0026rdquo; command line utility You can skip this step if you\u0026rsquo;re using the AVM template\u0026rsquo;s Codespace, as it is already installed.\nnewres will usually greatly speed up writing the resource module where there are a lot of parameters. In this example, there are only a few and isn\u0026rsquo;t really worth it, but we\u0026rsquo;ll continue so you see the method.\nIf you repeat this process with something with lots of parameters, like App Gateway, you\u0026rsquo;ll quickly see the benefit!\nAssuming you already have golang installed, run:\n1 go install github.com/lonegunmanb/newres/v3@latest Run the following to make a temporary folder for newres output and run the tool:\n1 2 3 mkdir newres cd newres newres -dir ./ -r azurerm_dev_center If successful, you\u0026rsquo;ll see:\n1 Successfully generated variables.tf and main.tf The newres naming convention needs an adjustment for AVM, in the generated main.tf, observe the variables all start dev_centre_ - we need to remove this prefix, leaving you with this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 resource \u0026#34;azurerm_dev_center\u0026#34; \u0026#34;this\u0026#34; { location = var.location name = var.name resource_group_name = var.resource_group_name tags = var.tags dynamic \u0026#34;identity\u0026#34; { for_each = var.identity == null ? [] : [var.identity] content { type = identity.value.type identity_ids = identity.value.identity_ids } } dynamic \u0026#34;timeouts\u0026#34; { for_each = var.timeouts == null ? [] : [var.timeouts] content { create = timeouts.value.create delete = timeouts.value.delete read = timeouts.value.read update = timeouts.value.update } } } This will also need to be fixed in the variables.tf file.\nnewres updates for main.tf Copy the contents of newres\\main.tf into main.tf, replacing this block:\n1 2 resource \u0026#34;azurerm_TODO_the_resource_for_this_module\u0026#34; \u0026#34;this\u0026#34; { } Remove the TODO from the top of the file \u0026amp; update the location as follows:\n1 location = coalesce(var.location, local.resource_group_location) Update the identity block in main.tf Update the dynamic \u0026ldquo;identity\u0026rdquo; block (assuming it exists), following the reference examples in the AVM interface specification for managed identities:\nMake sure to check the Hashicorp documentation to confirm the identities supported by the resource (SystemAssigned, UserAssigned, or both).\nThe identity block for the Dev Center resource shows that both types of identities are supported.\n1 2 3 4 5 6 7 dynamic \u0026#34;identity\u0026#34; { for_each = (var.managed_identities.system_assigned || length(var.managed_identities.user_assigned_resource_ids) \u0026gt; 0) ? { this = var.managed_identities } : {} content { type = identity.value.system_assigned \u0026amp;\u0026amp; length(identity.value.user_assigned_resource_ids) \u0026gt; 0 ? \u0026#34;SystemAssigned, UserAssigned\u0026#34; : length(identity.value.user_assigned_resource_ids) \u0026gt; 0 ? \u0026#34;UserAssigned\u0026#34; : \u0026#34;SystemAssigned\u0026#34; identity_ids = identity.value.user_assigned_resource_ids } } The Terraform variable declaration in the specification has examples for other scenarios (e.g. SystemAssigned only, or UserAssigned only).\nnewres updates for variables.tf Edit the contents of newres\\variables.tf to remove the following variables:\nlocation name resource_group_name identity tags (we\u0026rsquo;re going to use the ones in the template, instead).\nCopy the remaining variables to the top of variables.tf file in the module root folder. (in our case, there is only a \u0026rsquo;timeouts\u0026rsquo; variable remaining).\nnewres tidy-up Remove the newres folder. By this point, any intellisense errors should be fixed in main.tf, and the top of the main.tf should look something like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 data \u0026#34;azurerm_resource_group\u0026#34; \u0026#34;parent\u0026#34; { count = var.location == null ? 1 : 0 name = var.resource_group_name } resource \u0026#34;azurerm_dev_center\u0026#34; \u0026#34;this\u0026#34; { location = coalesce(var.location, local.resource_group_location) name = var.name resource_group_name = var.resource_group_name tags = var.tags dynamic \u0026#34;identity\u0026#34; { for_each = (var.managed_identities.system_assigned || length(var.managed_identities.user_assigned_resource_ids) \u0026gt; 0) ? { this = var.managed_identities } : {} content { type = identity.value.system_assigned \u0026amp;\u0026amp; length(identity.value.user_assigned_resource_ids) \u0026gt; 0 ? \u0026#34;SystemAssigned, UserAssigned\u0026#34; : length(identity.value.user_assigned_resource_ids) \u0026gt; 0 ? \u0026#34;UserAssigned\u0026#34; : \u0026#34;SystemAssigned\u0026#34; identity_ids = identity.value.user_assigned_resource_ids } } dynamic \u0026#34;timeouts\u0026#34; { for_each = var.timeouts == null ? [] : [var.timeouts] content { create = timeouts.value.create delete = timeouts.value.delete read = timeouts.value.read update = timeouts.value.update } } } # required AVM interfaces # (etc) TODO hunting There are a few \u0026ldquo;TODO\u0026rdquo; references in the files that need to be fixed and removed, ignore any that are in \u0026ldquo;README.md\u0026rdquo; because we\u0026rsquo;ll fix those when we automatically update the docs.\nmain.tf update azurerm_TODO_resource appropriately, e.g. azurerm_dev_center. locals.telemetry.tf set the module name and leave the module_type as \u0026ldquo;res\u0026rdquo;, e.g.: 1 2 3 telem_puid = \u0026#34;UNOFFICIAL\u0026#34; module_name = \u0026#34;res-devcenter-devcenter\u0026#34; module_type = \u0026#34;res\u0026#34; I suggest setting telem_puid to \u0026ldquo;UNOFFICIAL\u0026rdquo; in resources created for learning.\nmain.privateendpoint.tf You would typically update private_service_connection with the correct resource id and subresource name, something like this: 1 2 3 4 5 6 private_service_connection { name = each.value.private_service_connection_name != null ? each.value.private_service_connection_name : \u0026#34;pse-${var.name}\u0026#34; private_connection_resource_id = azurerm_TODO.this.id is_manual_connection = false subresource_names = [\u0026#34;TODO subresource name\u0026#34;] } However, in this case, Dev Center doesn\u0026rsquo;t support private endpoints, so we\u0026rsquo;re going to remove this file altogether.\nThere is a handy link in the template that helps find the right subresource name, should you need it for your resource.\nlocals.tf We don\u0026rsquo;t have any locals to add at the moment, so lets remove the reminder to \u0026ldquo;insert locals here\u0026rdquo; In our example, lets also remove the private endpoint local var, as we don\u0026rsquo;t need private endpoints. terraform.tf remove the reminder to add required providers providers should really be versioned like this (a correction to template is needed to align to AVM): 1 2 3 4 5 6 7 8 9 10 11 12 13 terraform { required_version = \u0026#34;\u0026gt;= 1.5.0\u0026#34; required_providers { azurerm = { source = \u0026#34;hashicorp/azurerm\u0026#34; version = \u0026#34;\u0026gt;= 3.71.0, \u0026lt; 4.0\u0026#34; } random = { source = \u0026#34;hashicorp/random\u0026#34; version = \u0026#34;\u0026gt;= 3.5.0, \u0026lt; 4.0\u0026#34; } } } variables.tf In the name variable, update the regex in the validation condition. If you\u0026rsquo;re not sure how to do this, remove the validation block for now and we will return to it later.\nSince our resource doesn\u0026rsquo;t support private endpoints, remove the \u0026ldquo;private_endpoints\u0026rdquo; variable.\nFor an unofficial module, you might want to consider setting the default value of the enable_telemetry variable to false.\noutputs.tf In this case, we don\u0026rsquo;t need the output private_endpoints. Remove the reminder TODO Update the resource output value \u0026amp; add a couple mandatory outputs missing from the template: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 output \u0026#34;resource\u0026#34; { value = azurerm_dev_center.this description = \u0026#34;This is the full output for the resource.\u0026#34; } output \u0026#34;id\u0026#34; { description = \u0026#34;The ID of the resource.\u0026#34; value = azurerm_dev_center.this.id } output \u0026#34;name\u0026#34; { description = \u0026#34;The name of the resource\u0026#34; value = azurerm_dev_center.this.id } _header.md If you\u0026rsquo;re using this for learning, remove the contents of this file and replace with something like this: 1 2 3 4 5 6 # terraform-azurerm-res-devcenter-devcenter This is a Terraform module for Azure Dev Center in the style of Azure Verified Modules. For official modules please see \u0026lt;https://aka.ms/AVM\u0026gt;. \u0026gt; [!WARNING] \u0026gt; Major version Zero (0.y.z) is for initial development. Anything MAY change at any time. A module SHOULD NOT be considered stable till at least it is major version one (1.0.0) or greater. Changes will always be via new versions being published and no changes will be made to existing published versions. For more details please go to \u0026lt;https://semver.org/\u0026gt; If this is not an official module, then I suggest removing the following files:\nSUPPORT.MD SECURITY.MD .github\\CODEOWNERS Creating the default example Each of the subfolders inside .\\examples contain a test that is run as part of the end-to-end tests during the the pull request workflow.\nAVM modules start with a \u0026ldquo;default\u0026rdquo; example - the purpose of this is to test the module in its simplest form with the minimum number of parameters.\nUpdate the default example In the default example, you may need to modify the resource group logic if you have policy that restricts where you can deploy resources:\n1 2 3 4 resource \u0026#34;azurerm_resource_group\u0026#34; \u0026#34;this\u0026#34; { name = module.naming.resource_group.name_unique location = \u0026#34;AustraliaEast\u0026#34; } In this case, the resource is only supported in the following regions, so pick one of these:\n\u0026lsquo;australiaeast,canadacentral,westeurope,japaneast,uksouth,eastus,eastus2,southcentralus,westus3,centralindia,eastasia,northeurope,koreacentral\u0026rsquo; This also means we can remove the logic that randomly selects a region:\nThe module call is at the end of main.tf, this would typically need adjustment to add the required variables, however in the case of Dev Center, just the name and resource group is enough:\n1 2 3 4 5 6 7 8 9 10 11 12 # This is the module call # Do not specify location here due to the randomization above. # Leaving location as `null` will cause the module to use the resource group location # with a data source. module \u0026#34;dev_center\u0026#34; { source = \u0026#34;../../\u0026#34; # source = \u0026#34;Azure/avm-res-devcenter-devcenter/azurerm\u0026#34; # ... enable_telemetry = var.enable_telemetry # see variables.tf name = module.naming.dev_test_lab.name_unique resource_group_name = azurerm_resource_group.this.name } Updating docs and running PR checks This requires Docker to be installed as the checks run in a container (The Codespace is set up with Docker support).\nThe AVM template includes a script to help running checks. There is a bash version (./avm) and a batch file version (./avm.bat). I recommend using the bash version.\nDon\u0026rsquo;t forget to check the line-encoding is set to \u0026ldquo;LF\u0026rdquo;, else you will get /usr/bin/env: ‘sh\\r’: No such file or directory.\nMark the file as executable the first time you use the script:\n1 chmod +x ./avm To update the docs:\n1 ./avm docs Once the container has been pulled, you\u0026rsquo;ll see output like this:\n1 2 3 4 5 6 curl -H \u0026#39;Cache-Control: no-cache, no-store\u0026#39; -sSL \u0026#34;\u0026#34;https://raw.githubusercontent.com/Azure/tfmod-scaffold/main/avm_scripts\u0026#34;/docs-gen.sh\u0026#34; | sh -s ==\u0026gt; Generating module documentation... README.md updated successfully ==\u0026gt; Generating examples documentation... ===\u0026gt; Generating examples documentation in ./default default/README.md updated successfully To confirm readiness for a Pull Request, run the following:\n1 ./avm pr-check At the time of writing, this will perform the following:\nensure each of the examples terraform validate run formatting and lint checks for go and terraform run any unit tests (not the end to end examples - they run during PR) GitHub runners Microsoft use internal runners for AVM end to end tests. If you\u0026rsquo;re not a Microsoft FTE, you\u0026rsquo;ll need to amend your E2E tests to use your own subscription\nTo do this, replace .github\\workflows\\e2e.yml with my version here:\nhttps://gist.github.com/kewalaka/93ec3da3c6a39610da3eef4b04c37365\nNote, running end to end tests deploys and destroys resources, thus does incur cost.\nRaise a PR If you\u0026rsquo;ve made it this far, and resolved any PR checks, you are ready to raise the initial pull request.\nIf you\u0026rsquo;ve been following along, hopefully success will smile down on you:\n\u0026hellip; at which your point can merge to main and congratulate yourself on getting this far!\nFind this on Github You can find the result of this blog post at this location:\nhttps://github.com/kewalaka/terraform-azurerm-avm-res-devcenter-devcenter\nWhere next There\u0026rsquo;s more to follow in future blog posts, here\u0026rsquo;s a taster:\nAdd child resources The scope of an AVM module must include \u0026ldquo;child\u0026rdquo; resources within the same resource provider scope, which for Dev Centre is here.\nIn the case of Dev Center, this means the module needs to be extended to include dev center projects. Other child resource such as DevBox definitions and Gallery support will require use of the AzAPI provider, as they are not yet covered by AzureRM.\nAdd more examples (end to end tests) Tests need to be added to provide coverage for resource functionality. See .\\examples\\README.md for more info on how to add new examples.\nWhere to look for inspiration Matt White (@matt-FFFFFF on Github) is the Microsoft lead for Azure Verified Modules, if you\u0026rsquo;re looking for inspiration then I recommend checking out his Key Vault module here:\nhttps://github.com/Azure/terraform-azurerm-avm-res-keyvault-vault\nYou can also check out some of my own AVM-style modules, e.g. these ones in the Azure org that I have helped co-author:\nhttps://github.com/Azure/terraform-azurerm-avm-res-containerregistry-registry https://github.com/Azure/terraform-azurerm-avm-res-app-managedenvironment https://github.com/Azure/terraform-azurerm-avm-res-eventhub-namespace \u0026amp; you can find more on my GitHub account, that I\u0026rsquo;m in the progress of contributing:\nhttps://github.com/kewalaka/terraform-azurerm-avm-res-sql-server https://github.com/kewalaka/terraform-azurerm-avm-res-cognitiveservices-account https://github.com/kewalaka/terraform-azurerm-res-storage-storageaccount Below is an \u0026ldquo;AVM-style\u0026rdquo; Container Apps that uses an AzureRM-like interface, whilst using AzAPI internally:\nhttps://github.com/kewalaka/terraform-azapi-res-app-containerapp ","date":"2024-02-01T19:08:03+13:00","image":"https://blog.kewalaka.nz/p/2024/02/write-an-avm-module/Azure-Verified-Modules-2783756541_hu569cbc7674f36d790c33c17d87477a75_58340_120x120_fill_box_smart1_3.png","permalink":"https://blog.kewalaka.nz/p/2024/02/write-an-avm-module/","title":"How to write your first AVM resource module"},{"content":"newres is a command line utility that helps you write Terraform modules faster. It supports multiple cloud providers (e.g. azure, aws, gcp), and several other providers too (e.g. kubernetes \u0026amp; tls).\nUsage To use, is as easy as:\n1 newres -dir [DIRECTORY] [-u] [-r RESOURCE_TYPE] \u0026hellip;e.g. for an Azure Resource Group:\n1 newres -dir ./ -r azurerm_resource_group This will create the \u0026lsquo;main.tf\u0026rsquo; and \u0026lsquo;variables.tf\u0026rsquo; covering the arguments from the schema documentation. The example screenshot below shows the start of main.tf for a cognitive services account resource, illustrating the coverage and the use of dynamics for optional blocks.\nThe tool can be run multiple times in the same directory, allowing you to continue to add more resource types to the main.tf \u0026amp; variables.tf files.\nUnified variable option The \u0026lsquo;unified\u0026rsquo; variable flag (\u0026rsquo;-u\u0026rsquo;) is particularly useful for writing the variable definitions for child resources in modules, such as the database resource in a sql server module.\nAvailability \u0026amp; instructions More details, including installation instructions, available on the official github site.\n","date":"2023-12-24T14:06:46+13:00","image":"https://blog.kewalaka.nz/p/2023/12/newres-cli/th-3033017124_hub328748851898d6402f341c1829d7f43_27937_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.kewalaka.nz/p/2023/12/newres-cli/","title":"Use the \"newres\" cli to make Terraform modules faster."},{"content":" original credit: @ctomeo\nPrivacy is normal Privacy is for good guys. It\u0026rsquo;s for mums and bike messengers and foodies.\nPrivacy is for business meetings and voting booths.\nIt\u0026rsquo;s why we have shower curtains.\nIt\u0026rsquo;s why we have that little padlock icon in our browser bar.\nPrivacy protects you from discrimination and from identity theft, and it keeps your food-delivery history under wraps.\nIt can also shield you from those creepy somebody-has-definitely-been-listening-to-my-thoughts ads on social media apps.\nPrivacy gives you the power to choose what and with whom you\u0026rsquo;ll share.\nIt provides safety, control and the right to grant access.\nPrivacy gives you the ability to express yourself\nTo be creative, to spend your time and your money in whatever manner you like, without the scrutiny of others. It protects our intimate moments, our most embarrassing ambitions, our radical ideas and the ability to be our true selves.\nPrivacy is freedom, consent, dignity and security\nPrivacy is normal. ","date":"2023-10-27T16:45:12+10:00","image":"https://blog.kewalaka.nz/p/2023/10/privacy-is-normal/privacy-is-normal_hu731fda7cf2a99bf9f7d0da64338ff9fb_3617879_120x120_fill_box_smart1_3.png","permalink":"https://blog.kewalaka.nz/p/2023/10/privacy-is-normal/","title":"Privacy matters"},{"content":"Azure Verified Modules is an initiative in development from Microsoft that seeks to unify many previous attempts to standardarise Infrastructure as Code modules on the Azure platform. The initiative aims to establish strategy, governance, and create a brand that becomes the go to place for resources \u0026amp; patterns, currently targeting Bicep and Terraform.\nMicrosoft\u0026rsquo;s aim is to \u0026ldquo;consolidate and set the standards for what a good Infrastructure-as-Code module looks like\u0026rdquo;, following the principles of the Well Architected Framework, evolving existing efforts such as the CARML library for Bicep resources.\nI\u0026rsquo;m particularly excited to see the direction for the Terraform modules, this would benefit from such a focal point, and I hope it will unify what I believe has been a fragmented ecosystem on the Azure platform.\nThe initiative is at an early stage, and not yet open to contributions outside of Microsoft, but if you\u0026rsquo;re interested or working in the DevOps space on the Azure platform, I believe this is one to watch!\n","date":"2023-09-25T07:32:14+13:00","image":"https://blog.kewalaka.nz/p/2023/09/azure-verified-modules/avm_hue3b3e79cae567de3ff62a3d95e3d5aa2_17051_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.kewalaka.nz/p/2023/09/azure-verified-modules/","title":"Azure Verified Modules"},{"content":"The command to create a new Hugo post is:\n1 hugo new \u0026lt;path to new content\u0026gt; Use an alias Using Powershell, you can use an alias to make this easier, here is the block of code we are going to use:\n1 2 3 4 5 6 7 8 9 10 11 12 13 function New-HugoPost { param ( [string]$PostName ) # UPDATE ME TO POINT TO YOUR BLOG PATH $blogPath = \u0026#34;c:\\path\\to\\your\\blog\u0026#34; set-location $blogPath \u0026amp; hugo.exe new \u0026#34;content\\post\\$PostName\\index.md\u0026#34; -c $blogPath } Set-Alias nhp New-HugoPost This can be reloaded each time Powershell starts by editing your profile:\n1 2 3 4 5 6 7 # open up the profile notepad $profile # # ** paste in the code block above \u0026amp; save ** # # reload the profile . $profile Test it works Then, to create a new post using the new, friendly nhp alias:\n1 nhp my-new-post ","date":"2023-07-12T00:00:00Z","image":"https://blog.kewalaka.nz/p/2023/07/hugo-pwsh-alias/windows-powershell-eyecatch-4060478705_hu06d9b35f0ee4de2e23c86b90f0cc809d_18506_120x120_fill_box_smart1_3.png","permalink":"https://blog.kewalaka.nz/p/2023/07/hugo-pwsh-alias/","title":"Use an alias in your PowerShell profile to create a new Hugo post"},{"content":"This is a summary of useful git config commands. Git settings exist in a hierachy, for Windows the default locations are:\nSystem wide - %programfiles%\\Git\\etc\\gitconfig Global - %userprofile%.gitconfig Local to the repository - .git/config Common global properties These ones are recommended to be set after Git has been installed:\ngit config --global user.name \u0026quot;your name\u0026quot; git config --global user.email you@example.com Overriding properties Settings lower in the hierachy override, so for example, if you need to use a different user name and email for a particular repository:\ngit config user.name \u0026quot;your name\u0026quot; git config user.email you@example.com Run this in the git repository you wish to modify. Local is implied if another scope such as --global is not specified.\nListing settings List global settings: git config --global --list List only local settings: git config --local --list Show where settings apply from: git config --list --show-origin Useful settings git config --global init.defaultbranch main will set the default branch to any new repository to \u0026lsquo;main\u0026rsquo; git config --global user.signingkey \u0026lt;your key\u0026gt; allows you to set your GPG key for signing commits git config --global credential.msauthflow system will set the git credential manager to use your system default browser (otherwise it can use IE) Removing settings This is done using --unset or --unset-all if you want to remove all settings with a particular property, e.g.:\ngit config --global --unset user.signingkey An example of removing a local config setting with a specific value (user name: \u0026ldquo;Mr X\u0026rdquo;):\ngit config --unset user.name \u0026quot;Mr X\u0026quot; Git Credential Manager If you\u0026rsquo;re using Git for Windows, you automatically have git credential manager installed so you don\u0026rsquo;t have to continuously authenticate.\nThis adds a new global setting credential.helper=manager\n","date":"2023-05-15T00:00:00Z","image":"https://blog.kewalaka.nz/p/2023/05/git-config-starter/img_git-config-featured-4001369487_hue4367cb3c75855bbb8191044f26a15a6_3416_120x120_fill_box_smart1_3.png","permalink":"https://blog.kewalaka.nz/p/2023/05/git-config-starter/","title":"Useful git config settings"},{"content":" Photo by George Hodan released under Public Domain license.\n","date":"2023-04-17T00:00:00Z","image":"https://blog.kewalaka.nz/p/hello-world/cat-in-suitcase_hu2841d26d7690759cf9360a2c6106be23_75641_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.kewalaka.nz/p/hello-world/","title":"Hello world, what shall we find here?"}]